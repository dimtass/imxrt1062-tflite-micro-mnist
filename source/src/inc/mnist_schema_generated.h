// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_MNISTPROT_H_
#define FLATBUFFERS_GENERATED_SCHEMA_MNISTPROT_H_

#include "flatbuffers.h"

namespace MnistProt {

struct Stats;

struct InferenceInput;

struct InferenceOutput;

struct Commands;

enum Command {
  Command_CMD_GET_STATS = 0,
  Command_CMD_INFERENCE_INPUT = 1,
  Command_CMD_INFERENCE_OUTPUT = 2,
  Command_MIN = Command_CMD_GET_STATS,
  Command_MAX = Command_CMD_INFERENCE_OUTPUT
};

inline const Command (&EnumValuesCommand())[3] {
  static const Command values[] = {
    Command_CMD_GET_STATS,
    Command_CMD_INFERENCE_INPUT,
    Command_CMD_INFERENCE_OUTPUT
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[4] = {
    "CMD_GET_STATS",
    "CMD_INFERENCE_INPUT",
    "CMD_INFERENCE_OUTPUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (e < Command_CMD_GET_STATS || e > Command_CMD_INFERENCE_OUTPUT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

enum Mode {
  Mode_ACCELERATION_NONE = 0,
  Mode_ACCELERATION_CMSIS_NN = 1,
  Mode_MIN = Mode_ACCELERATION_NONE,
  Mode_MAX = Mode_ACCELERATION_CMSIS_NN
};

inline const Mode (&EnumValuesMode())[2] {
  static const Mode values[] = {
    Mode_ACCELERATION_NONE,
    Mode_ACCELERATION_CMSIS_NN
  };
  return values;
}

inline const char * const *EnumNamesMode() {
  static const char * const names[3] = {
    "ACCELERATION_NONE",
    "ACCELERATION_CMSIS_NN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMode(Mode e) {
  if (e < Mode_ACCELERATION_NONE || e > Mode_ACCELERATION_CMSIS_NN) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMode()[index];
}

struct Stats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_FREQ = 6,
    VT_MODE = 8
  };
  uint8_t version() const {
    return GetField<uint8_t>(VT_VERSION, 0);
  }
  uint32_t freq() const {
    return GetField<uint32_t>(VT_FREQ, 0);
  }
  MnistProt::Mode mode() const {
    return static_cast<MnistProt::Mode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_FREQ) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct StatsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint8_t version) {
    fbb_.AddElement<uint8_t>(Stats::VT_VERSION, version, 0);
  }
  void add_freq(uint32_t freq) {
    fbb_.AddElement<uint32_t>(Stats::VT_FREQ, freq, 0);
  }
  void add_mode(MnistProt::Mode mode) {
    fbb_.AddElement<int8_t>(Stats::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit StatsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatsBuilder &operator=(const StatsBuilder &);
  flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stats>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stats> CreateStats(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version = 0,
    uint32_t freq = 0,
    MnistProt::Mode mode = MnistProt::Mode_ACCELERATION_NONE) {
  StatsBuilder builder_(_fbb);
  builder_.add_freq(freq);
  builder_.add_mode(mode);
  builder_.add_version(version);
  return builder_.Finish();
}

struct InferenceInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIGIT = 4
  };
  const flatbuffers::Vector<float> *digit() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DIGIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIGIT) &&
           verifier.VerifyVector(digit()) &&
           verifier.EndTable();
  }
};

struct InferenceInputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_digit(flatbuffers::Offset<flatbuffers::Vector<float>> digit) {
    fbb_.AddOffset(InferenceInput::VT_DIGIT, digit);
  }
  explicit InferenceInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferenceInputBuilder &operator=(const InferenceInputBuilder &);
  flatbuffers::Offset<InferenceInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferenceInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferenceInput> CreateInferenceInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> digit = 0) {
  InferenceInputBuilder builder_(_fbb);
  builder_.add_digit(digit);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferenceInput> CreateInferenceInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *digit = nullptr) {
  auto digit__ = digit ? _fbb.CreateVector<float>(*digit) : 0;
  return MnistProt::CreateInferenceInput(
      _fbb,
      digit__);
}

struct InferenceOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_F = 4,
    VT_OUTPUT_N = 6,
    VT_TIMER_MS = 8
  };
  const flatbuffers::Vector<float> *output_f() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_OUTPUT_F);
  }
  uint8_t output_n() const {
    return GetField<uint8_t>(VT_OUTPUT_N, 0);
  }
  float timer_ms() const {
    return GetField<float>(VT_TIMER_MS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT_F) &&
           verifier.VerifyVector(output_f()) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_N) &&
           VerifyField<float>(verifier, VT_TIMER_MS) &&
           verifier.EndTable();
  }
};

struct InferenceOutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_f(flatbuffers::Offset<flatbuffers::Vector<float>> output_f) {
    fbb_.AddOffset(InferenceOutput::VT_OUTPUT_F, output_f);
  }
  void add_output_n(uint8_t output_n) {
    fbb_.AddElement<uint8_t>(InferenceOutput::VT_OUTPUT_N, output_n, 0);
  }
  void add_timer_ms(float timer_ms) {
    fbb_.AddElement<float>(InferenceOutput::VT_TIMER_MS, timer_ms, 0.0f);
  }
  explicit InferenceOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferenceOutputBuilder &operator=(const InferenceOutputBuilder &);
  flatbuffers::Offset<InferenceOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferenceOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> output_f = 0,
    uint8_t output_n = 0,
    float timer_ms = 0.0f) {
  InferenceOutputBuilder builder_(_fbb);
  builder_.add_timer_ms(timer_ms);
  builder_.add_output_f(output_f);
  builder_.add_output_n(output_n);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferenceOutput> CreateInferenceOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *output_f = nullptr,
    uint8_t output_n = 0,
    float timer_ms = 0.0f) {
  auto output_f__ = output_f ? _fbb.CreateVector<float>(*output_f) : 0;
  return MnistProt::CreateInferenceOutput(
      _fbb,
      output_f__,
      output_n,
      timer_ms);
}

struct Commands FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_STATS = 6,
    VT_INPUT = 8,
    VT_OUPUT = 10
  };
  MnistProt::Command cmd() const {
    return static_cast<MnistProt::Command>(GetField<int8_t>(VT_CMD, 0));
  }
  const MnistProt::Stats *stats() const {
    return GetPointer<const MnistProt::Stats *>(VT_STATS);
  }
  const MnistProt::InferenceInput *input() const {
    return GetPointer<const MnistProt::InferenceInput *>(VT_INPUT);
  }
  const MnistProt::InferenceOutput *ouput() const {
    return GetPointer<const MnistProt::InferenceOutput *>(VT_OUPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyTable(stats()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUPUT) &&
           verifier.VerifyTable(ouput()) &&
           verifier.EndTable();
  }
};

struct CommandsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(MnistProt::Command cmd) {
    fbb_.AddElement<int8_t>(Commands::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_stats(flatbuffers::Offset<MnistProt::Stats> stats) {
    fbb_.AddOffset(Commands::VT_STATS, stats);
  }
  void add_input(flatbuffers::Offset<MnistProt::InferenceInput> input) {
    fbb_.AddOffset(Commands::VT_INPUT, input);
  }
  void add_ouput(flatbuffers::Offset<MnistProt::InferenceOutput> ouput) {
    fbb_.AddOffset(Commands::VT_OUPUT, ouput);
  }
  explicit CommandsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandsBuilder &operator=(const CommandsBuilder &);
  flatbuffers::Offset<Commands> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Commands>(end);
    return o;
  }
};

inline flatbuffers::Offset<Commands> CreateCommands(
    flatbuffers::FlatBufferBuilder &_fbb,
    MnistProt::Command cmd = MnistProt::Command_CMD_GET_STATS,
    flatbuffers::Offset<MnistProt::Stats> stats = 0,
    flatbuffers::Offset<MnistProt::InferenceInput> input = 0,
    flatbuffers::Offset<MnistProt::InferenceOutput> ouput = 0) {
  CommandsBuilder builder_(_fbb);
  builder_.add_ouput(ouput);
  builder_.add_input(input);
  builder_.add_stats(stats);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

inline const MnistProt::Commands *GetCommands(const void *buf) {
  return flatbuffers::GetRoot<MnistProt::Commands>(buf);
}

inline const MnistProt::Commands *GetSizePrefixedCommands(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MnistProt::Commands>(buf);
}

inline bool VerifyCommandsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MnistProt::Commands>(nullptr);
}

inline bool VerifySizePrefixedCommandsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MnistProt::Commands>(nullptr);
}

inline void FinishCommandsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MnistProt::Commands> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCommandsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MnistProt::Commands> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MnistProt

#endif  // FLATBUFFERS_GENERATED_SCHEMA_MNISTPROT_H_
